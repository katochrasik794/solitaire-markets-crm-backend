import express from 'express';
import pool from '../config/database.js';
import { createWalletForUser } from '../services/wallet.service.js';
import { hashPassword, comparePassword, generateResetToken, generateOTP, validatePassword } from '../utils/helpers.js';
import { validateRegister, validateLogin, validateForgotPassword, validateResetPassword } from '../middleware/validate.js';
import { sendPasswordResetEmail, sendOTPEmail } from '../services/email.js';
import { sendWelcomeEmail, sendOTPVerificationEmail } from '../services/templateEmail.service.js';
import jwt from 'jsonwebtoken';
import { authenticate } from '../middleware/auth.js';

const router = express.Router();

/**
 * POST /api/auth/register
 * Register a new user
 */
router.post('/register', validateRegister, async (req, res, next) => {
  try {
    const { email, password, firstName, lastName, phoneCode, phoneNumber, country, referredBy } = req.body;

    // Check if user already exists
    const existingUser = await pool.query(
      'SELECT id FROM users WHERE email = $1',
      [email]
    );

    if (existingUser.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'User with this email already exists'
      });
    }

    // Validate referral code if provided
    if (referredBy) {
      const referrerResult = await pool.query(
        'SELECT id FROM users WHERE referral_code = $1',
        [referredBy]
      );

      if (referrerResult.rows.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Invalid referral code'
        });
      }
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Insert new user (referral_code will be auto-generated by trigger)
    const result = await pool.query(
      `INSERT INTO users (email, password_hash, first_name, last_name, phone_code, phone_number, country, referred_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       RETURNING id, email, first_name, last_name, country, referral_code, referred_by, created_at`,
      [email, passwordHash, firstName, lastName, phoneCode || null, phoneNumber || null, country || null, referredBy || null]
    );

    const user = result.rows[0];

    // Handle IB Request creation (if referred)
    if (referredBy) {
      try {
        // Get referrer's ID
        const referrerRes = await pool.query(
          'SELECT id FROM users WHERE referral_code = $1',
          [referredBy]
        );
        const referrerId = referrerRes.rows.length > 0 ? referrerRes.rows[0].id : null;

        if (referrerId) {
          // Check if there are commission rates (implies auto-approval)
          // For multi-level, commissionRates might be the encoded chain object
          const commissionData = req.body.commissionRates;
          const hasCustomData = commissionData && Object.keys(commissionData).length > 0;

          if (hasCustomData) {
            // Master's Custom Link logic
            const groupCommissions = {};
            const chainData = {};

            // Extract L1 rates for group_pip_commissions and store full chain
            Object.entries(commissionData).forEach(([groupId, data]) => {
              if (data.rates && data.rates.length > 0) {
                groupCommissions[groupId] = data.rates[0];
                chainData[groupId] = data.rates;
              }
            });

            await pool.query(
              `INSERT INTO ib_requests (user_id, status, ib_type, group_pip_commissions, commission_chain, ib_level, root_master_id, approved_at, referrer_ib_id, willing_to_become_ib, willing_to_sign_agreement)
               VALUES ($1, 'approved', 'sub_ib', $2, $3, 1, $4, NOW(), $4, 'yes', 'yes')`,
              [user.id, groupCommissions, chainData, referrerId]
            );
          } else {
            // Normal Referral Link: Check for inheritance from referrer
            const referrerIB = await pool.query(
              `SELECT commission_chain, ib_level, root_master_id FROM ib_requests 
                     WHERE user_id = $1 AND status = 'approved'`,
              [referrerId]
            );

            if (referrerIB.rows.length > 0) {
              const { commission_chain, ib_level, root_master_id } = referrerIB.rows[0];
              const nextLevel = (ib_level || 0) + 1;

              // Check if chain supports this next level
              const groupCommissions = {};
              let chainExhausted = true;

              if (commission_chain) {
                Object.entries(commission_chain).forEach(([groupId, rates]) => {
                  if (rates && rates.length >= nextLevel) {
                    groupCommissions[groupId] = rates[nextLevel - 1]; // nextLevel is 1-indexed, array is 0-indexed
                    if (groupCommissions[groupId] > 0) chainExhausted = false;
                  }
                });
              }

              if (!chainExhausted) {
                // Inherit Sub-IB status
                await pool.query(
                  `INSERT INTO ib_requests (user_id, status, ib_type, group_pip_commissions, commission_chain, ib_level, root_master_id, approved_at, referrer_ib_id, willing_to_become_ib, willing_to_sign_agreement)
                             VALUES ($1, 'approved', 'sub_ib', $2, $3, $4, $5, NOW(), $6, 'yes', 'yes')`,
                  [user.id, groupCommissions, commission_chain, nextLevel, root_master_id || referrerId, referrerId]
                );
              } else if (commission_chain) {
                // Chain is exhausted OR user is just a Trader, but we STILL store the chain for group restrictions
                await pool.query(
                  `INSERT INTO ib_requests (user_id, status, ib_type, commission_chain, ib_level, root_master_id, approved_at, referrer_ib_id, willing_to_become_ib, willing_to_sign_agreement)
                             VALUES ($1, 'approved', 'trader', $2, $3, $4, NOW(), $5, 'yes', 'yes')`,
                  [user.id, commission_chain, nextLevel, root_master_id || referrerId, referrerId]
                );
              }
            }
          }
        }
      } catch (ibError) {
        console.error('Auto IB request error (register):', ibError);
      }
    }

    // Automatically create wallet for this user
    try {
      await createWalletForUser(user.id);
    } catch (walletError) {
      console.error('Create wallet error (register):', walletError.message);
      // Do not fail registration if wallet creation fails; user can retry later
    }

    // Generate JWT token
    const token = jwt.sign(
      {
        id: user.id,
        email: user.email
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );

    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      data: {
        user: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          country: user.country,
          referralCode: user.referral_code,
          referredBy: user.referred_by
        },
        token
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    next(error);
  }
});

/**
 * POST /api/auth/login
 * Login user
 */
router.post('/login', validateLogin, async (req, res, next) => {
  try {
    const { email, password } = req.body;

    // Find user by email (include status and last_login so we can check inactivity)
    const result = await pool.query(
      'SELECT id, email, password_hash, first_name, last_name, country, referral_code, referred_by, status, last_login FROM users WHERE email = $1',
      [email]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    const user = result.rows[0];

    // Verify password first
    const isPasswordValid = await comparePassword(password, user.password_hash);

    if (!isPasswordValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    // Check account status - block banned and inactive users
    const userStatus = user.status ? user.status.toLowerCase() : 'active';

    if (userStatus === 'banned') {
      return res.status(403).json({
        success: false,
        message: 'Your account has been blocked. Please contact support.'
      });
    }

    if (userStatus === 'inactive') {
      // Generate activation token
      const activationToken = generateResetToken();
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24); // Token expires in 24 hours

      // Invalidate any existing unused tokens for this user
      await pool.query(
        'UPDATE password_reset_tokens SET used = TRUE WHERE user_id = $1 AND used = FALSE',
        [user.id]
      );

      // Store activation token in password_reset_tokens table (reusing the table)
      await pool.query(
        'INSERT INTO password_reset_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)',
        [user.id, activationToken, expiresAt]
      );

      const activationLink = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/activate-account?token=${activationToken}`;

      return res.status(403).json({
        success: false,
        requiresActivation: true,
        message: 'Your account has been inactive due to inactivity. Click here to activate your account.',
        activationLink: activationLink,
        email: user.email
      });
    }

    // Update last_login timestamp
    await pool.query(
      'UPDATE users SET last_login = NOW() WHERE id = $1',
      [user.id]
    );

    // Generate JWT token
    const token = jwt.sign(
      {
        id: user.id,
        email: user.email
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );

    res.json({
      success: true,
      message: 'Login successful',
      data: {
        user: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          country: user.country,
          referralCode: user.referral_code,
          referredBy: user.referred_by
        },
        token
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    next(error);
  }
});

/**
 * POST /api/auth/forgot-password
 * Request password reset - sends OTP
 */
router.post('/forgot-password', validateForgotPassword, async (req, res, next) => {
  try {
    const { email } = req.body;

    // Find user by email
    const result = await pool.query(
      'SELECT id, email FROM users WHERE email = $1',
      [email.trim().toLowerCase()]
    );

    // Don't reveal if user exists or not (security best practice)
    if (result.rows.length === 0) {
      return res.json({
        success: true,
        message: 'If an account with that email exists, an OTP has been sent to your email.'
      });
    }

    const user = result.rows[0];

    // Generate OTP
    const otp = generateOTP();
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + 10); // OTP expires in 10 minutes

    // Store OTP with user ID
    passwordResetOtpStore.set(email.trim().toLowerCase(), {
      otp,
      expiresAt,
      userId: user.id
    });

    // Send OTP email using template
    try {
      const userResult = await pool.query('SELECT first_name, last_name FROM users WHERE id = $1', [user.id]);
      const userName = userResult.rows.length > 0
        ? `${userResult.rows[0].first_name || ''} ${userResult.rows[0].last_name || ''}`.trim() || 'User'
        : 'User';
      await sendOTPVerificationEmail(user.email, userName, otp, 'Please use this code to reset your password.');
    } catch (emailError) {
      console.error('Email sending error:', emailError);
      // Fallback to old method
      try {
        await sendOTPEmail(user.email, otp);
      } catch (fallbackError) {
        passwordResetOtpStore.delete(email.trim().toLowerCase());
        return res.status(500).json({
          success: false,
          message: 'Failed to send OTP email. Please try again.'
        });
      }
    }

    res.json({
      success: true,
      message: 'If an account with that email exists, an OTP has been sent to your email.'
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    next(error);
  }
});

/**
 * POST /api/auth/verify-password-reset-otp
 * Verify OTP for password reset
 */
router.post('/verify-password-reset-otp', async (req, res, next) => {
  try {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({
        success: false,
        message: 'Email and OTP are required'
      });
    }

    const emailKey = email.trim().toLowerCase();
    const storedData = passwordResetOtpStore.get(emailKey);

    if (!storedData) {
      return res.status(400).json({
        success: false,
        message: 'OTP not found or expired. Please request a new OTP.'
      });
    }

    // Check if OTP has expired
    if (new Date() > new Date(storedData.expiresAt)) {
      passwordResetOtpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'OTP has expired. Please request a new OTP.'
      });
    }

    // Verify OTP
    if (storedData.otp !== otp) {
      return res.status(400).json({
        success: false,
        message: 'Invalid OTP. Please try again.'
      });
    }

    // OTP verified - return success (keep data in store for password reset)
    res.json({
      success: true,
      message: 'OTP verified successfully'
    });
  } catch (error) {
    console.error('Verify password reset OTP error:', error);
    next(error);
  }
});

/**
 * POST /api/auth/reset-password-with-otp
 * Reset password with verified OTP
 */
router.post('/reset-password-with-otp', async (req, res, next) => {
  try {
    const { email, otp, password } = req.body;

    if (!email || !otp || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email, OTP, and password are required'
      });
    }

    // Validate password
    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      return res.status(400).json({
        success: false,
        message: passwordValidation.message
      });
    }

    const emailKey = email.trim().toLowerCase();
    const storedData = passwordResetOtpStore.get(emailKey);

    if (!storedData) {
      return res.status(400).json({
        success: false,
        message: 'OTP session expired. Please request a new password reset.'
      });
    }

    // Check if OTP has expired
    if (new Date() > new Date(storedData.expiresAt)) {
      passwordResetOtpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'OTP has expired. Please request a new password reset.'
      });
    }

    // Verify OTP again
    if (storedData.otp !== otp) {
      return res.status(400).json({
        success: false,
        message: 'Invalid OTP. Please try again.'
      });
    }

    // Hash new password
    const passwordHash = await hashPassword(password);

    // Update user password
    await pool.query(
      'UPDATE users SET password_hash = $1 WHERE id = $2',
      [passwordHash, storedData.userId]
    );

    // Remove OTP from store
    passwordResetOtpStore.delete(emailKey);

    res.json({
      success: true,
      message: 'Password has been reset successfully'
    });
  } catch (error) {
    console.error('Reset password with OTP error:', error);
    next(error);
  }
});

/**
 * GET /api/auth/verify-token
 * Verify JWT token validity
 */
router.get('/verify-token', async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const token = authHeader.substring(7);

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      // Optionally fetch fresh user data from database
      const result = await pool.query(
        `SELECT u.id, u.email, u.first_name, u.last_name, u.country, u.referral_code, u.referred_by, u.is_banned,
                ir.ib_type, ir.plan_type, ir.status as ib_status
         FROM users u 
         LEFT JOIN ib_requests ir ON u.id = ir.user_id AND ir.status = 'approved'
         WHERE u.id = $1`,
        [decoded.id]
      );

      if (result.rows.length === 0) {
        return res.status(401).json({
          success: false,
          message: 'User not found'
        });
      }

      const user = result.rows[0];

      res.json({
        success: true,
        data: {
          user: {
            id: user.id,
            email: user.email,
            firstName: user.first_name,
            lastName: user.last_name,
            country: user.country,
            referralCode: user.referral_code,
            referredBy: user.referred_by,
            isBanned: user.is_banned,
            ibType: user.ib_type,
            planType: user.plan_type,
            ibStatus: user.ib_status
          }
        }
      });
    } catch (jwtError) {
      if (jwtError.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: 'Token has expired'
        });
      }
      throw jwtError;
    }
  } catch (error) {
    console.error('Verify token error:', error);
    next(error);
  }
});

// In-memory OTP storage (for production, use Redis or database)
const otpStore = new Map(); // email -> { otp, expiresAt, registrationData }
const passwordResetOtpStore = new Map(); // email -> { otp, expiresAt, userId }

/**
 * POST /api/auth/send-registration-otp
 * Send OTP for email verification during registration
 */
router.post('/send-registration-otp', async (req, res, next) => {
  try {
    const { email, password, firstName, lastName, phoneCode, phoneNumber, country, referredBy, commissionRates } = req.body;

    // Validate required fields
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({
        success: false,
        message: 'Email, password, first name, and last name are required'
      });
    }

    // Check if user already exists
    const existingUser = await pool.query(
      'SELECT id FROM users WHERE email = $1',
      [email.trim().toLowerCase()]
    );

    if (existingUser.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'User with this email already exists'
      });
    }

    // Validate referral code if provided
    if (referredBy) {
      const referrerResult = await pool.query(
        'SELECT id FROM users WHERE referral_code = $1',
        [referredBy]
      );

      if (referrerResult.rows.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Invalid referral code'
        });
      }
    }

    // Generate OTP
    const otp = generateOTP();
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + 10); // OTP expires in 10 minutes

    // Store OTP with registration data
    otpStore.set(email.trim().toLowerCase(), {
      otp,
      expiresAt,
      registrationData: {
        email: email.trim().toLowerCase(),
        password,
        firstName: firstName.trim(),
        lastName: lastName.trim(),
        phoneCode: phoneCode || null,
        phoneNumber: phoneNumber?.trim() || null,
        country: country || null,
        referredBy: referredBy || null,
        commissionRates: commissionRates || null
      }
    });

    // Send OTP email using template
    try {
      const userName = `${firstName.trim()} ${lastName.trim()}`.trim();
      await sendOTPVerificationEmail(email.trim().toLowerCase(), userName, otp, 'Please use this code to verify your registration.');
    } catch (emailError) {
      console.error('[REGISTER OTP] Email sending error:', {
        message: emailError.message,
        stack: emailError.stack,
        email: email.trim().toLowerCase()
      });
      // Fallback to old method
      try {
        await sendOTPEmail(email.trim().toLowerCase(), otp);
      } catch (fallbackError) {
        otpStore.delete(email.trim().toLowerCase());
        return res.status(500).json({
          success: false,
          message: fallbackError.message || 'Failed to send OTP email. Please check your email configuration and try again.'
        });
      }
    }

    res.json({
      success: true,
      message: 'OTP has been sent to your email address'
    });
  } catch (error) {
    console.error('[REGISTER OTP] Unexpected error:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    res.status(500).json({
      success: false,
      message: error.message || 'An unexpected error occurred. Please try again.'
    });
  }
});

/**
 * POST /api/auth/verify-registration-otp
 * Verify OTP and complete registration
 */
router.post('/verify-registration-otp', async (req, res, next) => {
  try {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({
        success: false,
        message: 'Email and OTP are required'
      });
    }

    const emailKey = email.trim().toLowerCase();
    const storedData = otpStore.get(emailKey);

    if (!storedData) {
      return res.status(400).json({
        success: false,
        message: 'OTP not found or expired. Please request a new OTP.'
      });
    }

    // Check if OTP has expired
    if (new Date() > new Date(storedData.expiresAt)) {
      otpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'OTP has expired. Please request a new OTP.'
      });
    }

    // Verify OTP
    if (storedData.otp !== otp) {
      return res.status(400).json({
        success: false,
        message: 'Invalid OTP. Please try again.'
      });
    }

    // OTP verified, proceed with registration
    const { registrationData } = storedData;

    // Double-check user doesn't exist (race condition protection)
    const existingUser = await pool.query(
      'SELECT id FROM users WHERE email = $1',
      [emailKey]
    );

    if (existingUser.rows.length > 0) {
      otpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'User with this email already exists'
      });
    }

    // Hash password
    const passwordHash = await hashPassword(registrationData.password);

    // Insert new user
    const result = await pool.query(
      `INSERT INTO users (email, password_hash, first_name, last_name, phone_code, phone_number, country, referred_by, is_email_verified)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
       RETURNING id, email, first_name, last_name, country, referral_code, referred_by, created_at`,
      [
        registrationData.email,
        passwordHash,
        registrationData.firstName,
        registrationData.lastName,
        registrationData.phoneCode,
        registrationData.phoneNumber,
        registrationData.country,
        registrationData.referredBy,
        true // Email is verified
      ]
    );

    const user = result.rows[0];

    // Automatically create wallet for this user
    try {
      await createWalletForUser(user.id);
    } catch (walletError) {
      console.error('Create wallet error (register):', walletError.message);
      // Do not fail registration if wallet creation fails; user can retry later
    }

    // Remove OTP from store
    otpStore.delete(emailKey);

    // Handle IB Request creation (if referred)
    if (registrationData.referredBy) {
      try {
        // Get referrer's ID
        const referrerRes = await pool.query(
          'SELECT id FROM users WHERE referral_code = $1',
          [registrationData.referredBy]
        );
        const referrerId = referrerRes.rows.length > 0 ? referrerRes.rows[0].id : null;

        const commissionData = registrationData.commissionRates;
        const hasCustomData = commissionData && Object.keys(commissionData).length > 0;

        if (hasCustomData) {
          // Master's Custom Link logic
          const groupCommissions = {};
          const chainData = {};

          Object.entries(commissionData).forEach(([groupId, data]) => {
            if (data.rates && data.rates.length > 0) {
              groupCommissions[groupId] = data.rates[0];
              chainData[groupId] = data.rates;
            }
          });

          await pool.query(
            `INSERT INTO ib_requests (user_id, status, ib_type, group_pip_commissions, commission_chain, ib_level, root_master_id, approved_at, referrer_ib_id, willing_to_become_ib, willing_to_sign_agreement)
             VALUES ($1, 'approved', 'sub_ib', $2, $3, 1, $4, NOW(), $4, 'yes', 'yes')`,
            [user.id, groupCommissions, chainData, referrerId]
          );
          console.log(`User ${user.id} automatically approved as L1 Sub-IB via custom chain`);
        } else if (referrerId) {
          // Normal Referral Link: Inheritance
          const referrerIB = await pool.query(
            `SELECT commission_chain, ib_level, root_master_id FROM ib_requests 
             WHERE user_id = $1 AND status = 'approved'`,
            [referrerId]
          );

          if (referrerIB.rows.length > 0) {
            const { commission_chain, ib_level, root_master_id } = referrerIB.rows[0];
            const nextLevel = (ib_level || 0) + 1;

            const groupCommissions = {};
            let chainExhausted = true;

            if (commission_chain) {
              Object.entries(commission_chain).forEach(([groupId, rates]) => {
                if (rates && rates.length >= nextLevel) {
                  groupCommissions[groupId] = rates[nextLevel - 1];
                  if (groupCommissions[groupId] > 0) chainExhausted = false;
                }
              });
            }

            if (!chainExhausted) {
              await pool.query(
                `INSERT INTO ib_requests (user_id, status, ib_type, group_pip_commissions, commission_chain, ib_level, root_master_id, approved_at, referrer_ib_id, willing_to_become_ib, willing_to_sign_agreement)
                 VALUES ($1, 'approved', 'sub_ib', $2, $3, $4, $5, NOW(), $6, 'yes', 'yes')`,
                [user.id, groupCommissions, commission_chain, nextLevel, root_master_id || referrerId, referrerId]
              );
              console.log(`User ${user.id} automatically approved as L${nextLevel} Sub-IB via inheritance`);
            }
          }
        }
      } catch (ibError) {
        console.error('Auto IB request error (verify-otp):', ibError);
      }
    }

    // Send welcome email using template
    setImmediate(async () => {
      try {
        const userName = `${user.first_name || ''} ${user.last_name || ''}`.trim() || 'Valued Customer';
        await sendWelcomeEmail(user.email, userName);
        console.log(`Welcome email sent to ${user.email}`);
      } catch (emailError) {
        console.error('Failed to send welcome email:', emailError);
        // Don't fail registration if email fails
      }
    });

    // Generate JWT token
    const token = jwt.sign(
      {
        id: user.id,
        email: user.email
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );

    res.status(201).json({
      success: true,
      message: 'Registration successful and email verified',
      data: {
        user: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          country: user.country,
          referralCode: user.referral_code,
          referredBy: user.referred_by
        },
        token
      }
    });
  } catch (error) {
    console.error('Verify registration OTP error:', error);
    next(error);
  }
});

/**
 * GET /api/auth/referrer/:code
 * Get referrer details by code
 */
router.get('/referrer/:code', async (req, res, next) => {
  try {
    const { code } = req.params;

    const result = await pool.query(
      'SELECT first_name, last_name FROM users WHERE referral_code = $1',
      [code]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Invalid referral code'
      });
    }

    const user = result.rows[0];
    res.json({
      success: true,
      name: `${user.first_name || ''} ${user.last_name || ''}`.trim()
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/auth/verify-reactivation-otp
 * Verify OTP and reactivate inactive account
 */
router.post('/verify-reactivation-otp', async (req, res, next) => {
  try {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({
        success: false,
        message: 'Email and OTP are required'
      });
    }

    const emailKey = email.trim().toLowerCase();
    const storedData = passwordResetOtpStore.get(emailKey);

    if (!storedData || storedData.type !== 'reactivation') {
      return res.status(400).json({
        success: false,
        message: 'OTP not found or expired. Please try logging in again.'
      });
    }

    // Check if OTP has expired
    if (new Date() > new Date(storedData.expiresAt)) {
      passwordResetOtpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'OTP has expired. Please try logging in again.'
      });
    }

    // Verify OTP
    if (storedData.otp !== otp) {
      return res.status(400).json({
        success: false,
        message: 'Invalid OTP. Please try again.'
      });
    }

    // Reactivate account and update last_login
    await pool.query(
      'UPDATE users SET status = $1, last_login = NOW() WHERE id = $2',
      ['active', storedData.userId]
    );

    // Remove OTP from store
    passwordResetOtpStore.delete(emailKey);

    // Get updated user data
    const userResult = await pool.query(
      'SELECT id, email, first_name, last_name, country, referral_code, referred_by FROM users WHERE id = $1',
      [storedData.userId]
    );

    const user = userResult.rows[0];

    // Generate JWT token
    const token = jwt.sign(
      {
        id: user.id,
        email: user.email
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );

    res.json({
      success: true,
      message: 'Account reactivated successfully',
      data: {
        user: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          country: user.country,
          referralCode: user.referral_code,
          referredBy: user.referred_by
        },
        token
      }
    });
  } catch (error) {
    console.error('Verify reactivation OTP error:', error);
    next(error);
  }
});

/**
 * GET /api/auth/activate-account/:token
 * Send OTP when user clicks activation link
 */
router.get('/activate-account/:token', async (req, res, next) => {
  try {
    const { token } = req.params;

    // First, ensure status column exists (auto-migration)
    try {
      await pool.query(`
        DO $$ 
        BEGIN
          IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'users' AND column_name = 'status'
          ) THEN
            ALTER TABLE users 
            ADD COLUMN status VARCHAR(20) DEFAULT 'active' 
            CHECK (status IN ('active', 'banned', 'inactive'));
            
            UPDATE users SET status = 'active' WHERE status IS NULL;
            
            CREATE INDEX IF NOT EXISTS idx_users_status ON users(status);
          END IF;
        END $$;
      `);
    } catch (migrationError) {
      console.error('Auto-migration check error (non-critical):', migrationError);
      // Continue anyway - column might already exist or migration might have failed
    }

    // Find valid activation token
    const tokenResult = await pool.query(
      `SELECT prt.id, prt.user_id, prt.expires_at, prt.used, u.email, COALESCE(u.status, 'active') as status
       FROM password_reset_tokens prt
       JOIN users u ON prt.user_id = u.id
       WHERE prt.token = $1 AND prt.used = FALSE`,
      [token]
    );

    if (tokenResult.rows.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired activation link'
      });
    }

    const tokenData = tokenResult.rows[0];

    // Check if token has expired
    if (new Date() > new Date(tokenData.expires_at)) {
      return res.status(400).json({
        success: false,
        message: 'Activation link has expired. Please request a new one by trying to login again.'
      });
    }

    // Check if user is already active
    if (tokenData.status && tokenData.status.toLowerCase() === 'active') {
      return res.status(400).json({
        success: false,
        message: 'Your account is already active. You can login now.'
      });
    }

    // Generate OTP
    const otp = generateOTP();
    const otpExpiresAt = new Date();
    otpExpiresAt.setMinutes(otpExpiresAt.getMinutes() + 10); // OTP expires in 10 minutes

    // Store OTP with user ID for activation
    passwordResetOtpStore.set(tokenData.email.trim().toLowerCase(), {
      otp,
      expiresAt: otpExpiresAt,
      userId: tokenData.user_id,
      type: 'activation',
      activationToken: token
    });

    // Send OTP email
    try {
      await sendOTPEmail(tokenData.email, otp);
    } catch (emailError) {
      console.error('Email sending error:', emailError);
      passwordResetOtpStore.delete(tokenData.email.trim().toLowerCase());
      return res.status(500).json({
        success: false,
        message: 'Failed to send OTP email. Please try again.'
      });
    }

    res.json({
      success: true,
      message: 'OTP has been sent to your email address',
      email: tokenData.email
    });
  } catch (error) {
    console.error('Activate account error:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      detail: error.detail
    });

    // Check if it's a column doesn't exist error
    if (error.code === '42703' || error.message?.includes('column') && error.message?.includes('does not exist')) {
      return res.status(500).json({
        success: false,
        message: 'Database migration required. Please run the migration to add status column to users table.'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Failed to process activation request. Please try again.'
    });
  }
});

/**
 * POST /api/auth/verify-activation-otp
 * Verify OTP and activate account
 */
router.post('/verify-activation-otp', async (req, res, next) => {
  try {
    const { email, otp, token } = req.body;

    if (!email || !otp || !token) {
      return res.status(400).json({
        success: false,
        message: 'Email, OTP, and activation token are required'
      });
    }

    // Verify activation token
    const tokenResult = await pool.query(
      `SELECT prt.id, prt.user_id, prt.expires_at, prt.used, u.email, u.status
       FROM password_reset_tokens prt
       JOIN users u ON prt.user_id = u.id
       WHERE prt.token = $1 AND prt.used = FALSE`,
      [token]
    );

    if (tokenResult.rows.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired activation token'
      });
    }

    const tokenData = tokenResult.rows[0];

    // Check if token has expired
    if (new Date() > new Date(tokenData.expires_at)) {
      return res.status(400).json({
        success: false,
        message: 'Activation token has expired. Please request a new one by trying to login again.'
      });
    }

    // Verify OTP
    const emailKey = email.trim().toLowerCase();
    const storedData = passwordResetOtpStore.get(emailKey);

    if (!storedData || storedData.type !== 'activation' || storedData.activationToken !== token) {
      return res.status(400).json({
        success: false,
        message: 'OTP not found or expired. Please request a new OTP.'
      });
    }

    // Check if OTP has expired
    if (new Date() > new Date(storedData.expiresAt)) {
      passwordResetOtpStore.delete(emailKey);
      return res.status(400).json({
        success: false,
        message: 'OTP has expired. Please request a new OTP.'
      });
    }

    // Verify OTP
    if (storedData.otp !== otp) {
      return res.status(400).json({
        success: false,
        message: 'Invalid OTP. Please try again.'
      });
    }

    // Activate account and update last_login
    await pool.query(
      'UPDATE users SET status = $1, last_login = NOW() WHERE id = $2',
      ['active', tokenData.user_id]
    );

    // Mark activation token as used
    await pool.query(
      'UPDATE password_reset_tokens SET used = TRUE WHERE id = $1',
      [tokenResult.rows[0].id]
    );

    // Remove OTP from store
    passwordResetOtpStore.delete(emailKey);

    // Get updated user data
    const userResult = await pool.query(
      'SELECT id, email, first_name, last_name, country, referral_code, referred_by FROM users WHERE id = $1',
      [tokenData.user_id]
    );

    const user = userResult.rows[0];

    // Generate JWT token
    const jwtToken = jwt.sign(
      {
        id: user.id,
        email: user.email
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );

    res.json({
      success: true,
      message: 'Account activated successfully',
      data: {
        user: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          country: user.country,
          referralCode: user.referral_code,
          referredBy: user.referred_by
        },
        token: jwtToken
      }
    });
  } catch (error) {
    console.error('Verify activation OTP error:', error);
    next(error);
  }
});

/**
 * GET /api/auth/profile
 * Get authenticated user's profile with status and details
 */
router.get('/profile', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;

    // Get user profile - select only columns that definitely exist
    const userResult = await pool.query(
      `SELECT 
        id, email, first_name, last_name, phone_code, phone_number, country,
        is_email_verified, referral_code, referred_by,
        created_at, updated_at, last_login
      FROM users 
      WHERE id = $1`,
      [userId]
    );

    // Try to get status and kyc_status if columns exist
    let userStatus = 'active';
    let userKycStatus = 'unverified';
    try {
      const statusResult = await pool.query(
        `SELECT status, kyc_status FROM users WHERE id = $1`,
        [userId]
      );
      if (statusResult.rows.length > 0) {
        userStatus = statusResult.rows[0].status || 'active';
        userKycStatus = statusResult.rows[0].kyc_status || 'unverified';
      }
    } catch (statusError) {
      // Columns don't exist, use defaults
      console.log('Status/kyc_status columns not found, using defaults');
    }

    if (userResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const user = userResult.rows[0];

    // Get wallet balance
    const walletResult = await pool.query(
      'SELECT balance, currency FROM wallets WHERE user_id = $1 LIMIT 1',
      [userId]
    );
    const wallet = walletResult.rows[0] || null;

    // Get KYC verification details
    const kycResult = await pool.query(
      `SELECT status, submitted_at, reviewed_at, rejection_reason 
       FROM kyc_verifications 
       WHERE user_id = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [userId]
    );
    const kyc = kycResult.rows[0] || null;

    // Get trading accounts count
    const accountsResult = await pool.query(
      'SELECT COUNT(*) as count FROM trading_accounts WHERE user_id = $1',
      [userId]
    );
    const accountsCount = parseInt(accountsResult.rows[0]?.count || 0);

    res.json({
      success: true,
      data: {
        profile: {
          id: user.id,
          email: user.email,
          firstName: user.first_name,
          lastName: user.last_name,
          phoneCode: user.phone_code,
          phoneNumber: user.phone_number,
          country: user.country,
          countryCode: null, // Not stored in users table - would need to join with countries table
          status: userStatus,
          kycStatus: userKycStatus,
          isEmailVerified: user.is_email_verified,
          referralCode: user.referral_code,
          referredBy: user.referred_by,
          createdAt: user.created_at,
          updatedAt: user.updated_at,
          lastLogin: user.last_login
        },
        wallet: wallet ? {
          balance: parseFloat(wallet.balance || 0),
          currency: wallet.currency || 'USD'
        } : null,
        kyc: kyc ? {
          status: kyc.status,
          submittedAt: kyc.submitted_at,
          reviewedAt: kyc.reviewed_at,
          rejectionReason: kyc.rejection_reason
        } : null,
        accountsCount
      }
    });
  } catch (error) {
    console.error('Get profile error:', error);
    console.error('Error stack:', error.stack);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch profile',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * GET /api/auth/logs
 * Get authenticated user's activity logs
 */
router.get('/logs', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit = 50, offset = 0 } = req.query;

    // Get total count
    const countResult = await pool.query(
      'SELECT COUNT(*) as total FROM logs_of_users WHERE user_id = $1',
      [userId]
    );
    const total = parseInt(countResult.rows[0]?.total || 0);

    // Get logs
    const logsResult = await pool.query(
      `SELECT 
        id, action_type, action_category, description, 
        ip_address, user_agent, created_at
      FROM logs_of_users
      WHERE user_id = $1
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3`,
      [userId, parseInt(limit), parseInt(offset)]
    );

    res.json({
      success: true,
      data: {
        logs: logsResult.rows,
        total,
        limit: parseInt(limit),
        offset: parseInt(offset)
      }
    });
  } catch (error) {
    console.error('Get logs error:', error);
    console.error('Error stack:', error.stack);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to fetch logs',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * OPTIONS /api/auth/change-password
 * Handle CORS preflight for change-password
 */
router.options('/change-password', (req, res) => {
  console.log('üîê OPTIONS preflight for change-password');
  res.header('Access-Control-Allow-Methods', 'PUT, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.sendStatus(200);
});

/**
 * PUT /api/auth/change-password
 * Change user password (requires current password)
 */
router.put('/change-password', (req, res, next) => {
  console.log('üîê PUT /change-password hit - method:', req.method, 'originalMethod:', req.headers['x-original-method'] || 'N/A');
  next();
}, authenticate, async (req, res) => {
  try {
    console.log('üîê Change password request received:', {
      method: req.method,
      path: req.path,
      hasBody: !!req.body,
      bodyKeys: req.body ? Object.keys(req.body) : []
    });

    const userId = req.user.id;
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'Current password and new password are required'
      });
    }

    // Validate new password
    const passwordValidation = validatePassword(newPassword);
    if (!passwordValidation.valid) {
      return res.status(400).json({
        success: false,
        message: passwordValidation.message
      });
    }

    // Get user's current password hash
    const userResult = await pool.query(
      'SELECT password_hash FROM users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // Verify current password
    const isCurrentPasswordValid = await comparePassword(
      currentPassword,
      userResult.rows[0].password_hash
    );

    if (!isCurrentPasswordValid) {
      return res.status(400).json({
        success: false,
        message: 'Current password is incorrect'
      });
    }

    // Hash new password
    const newPasswordHash = await hashPassword(newPassword);

    // Update password
    await pool.query(
      'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2',
      [newPasswordHash, userId]
    );

    res.json({
      success: true,
      message: 'Password changed successfully'
    });
  } catch (error) {
    console.error('Change password error:', error);
    console.error('Error stack:', error.stack);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to change password',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

export default router;

